<!DOCTYPE html>
<html lang=zh-CN>
  <head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <meta name="description" content="">
  <meta name="keywords" content="">
  
    <link rel="icon" href="/favicon.ico">
  
    
  <title>FastDFS分布式文件系统 | luguoyuan</title>
  <link rel="stylesheet" href="/style.css">
  <link rel="stylesheet" href="/lib/jquery.fancybox.min.css">
  <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
</head>

<body>
  <header>
  <div class="header-container">
    <a class='logo' href="/">
      <span>luguoyuan</span>
    </a>
    <ul class="right-header">
      
        <li class="nav-item">
          
            <a href="/" class="item-link">首页</a>
          
        </li>
      
        <li class="nav-item">
          
            <a href="/about" class="item-link">关于</a>
          
        </li>
      
        <li class="nav-item">
          
            <a href="/archives" class="item-link">归档</a>
          
        </li>
      
        <li class="nav-item">
          
            <a href="/tags" class="item-link">标签</a>
          
        </li>
      
    </ul>
  </div>
</header>

  <main id='post'>
  <div class="content">
    <article>
        <section class="content markdown-body">
          <h1>FastDFS分布式文件系统</h1>
          <div class='post-meta'>
            <i class="fa fa-calendar" aria-hidden="true"></i> <time>2018年07月10日</time>
            
            
              | 
                  <i class="fa fa-tag" aria-hidden="true"></i>
                
               
  <a href="/tags/#FastDfs" class='tag'>FastDfs</a>


            
          </div>
          <h3 id="FastDFS介绍"><a href="#FastDFS介绍" class="headerlink" title="FastDFS介绍"></a>FastDFS介绍</h3><p>​         FastDFS是一个开源的轻量级分布式文件系统，由跟踪服务器（tracker server）、存储服务器（storage server）和客户端（client）三个部分组成，主要解决了海量数据存储问题，特别适合以中小文件（建议范围：4KB &lt; file_size &lt;500MB）为载体的在线服务。</p>
<p><img src="D:\javasoft\blog\source\image\1531229904416.png" alt="1531229904416"></p>
<p>###Storage server</p>
<p>​    Storage server（后简称storage）以组（卷，group或volume）为单位组织，一个group内包含多台storage机器，数据互为备份，存储空间以group内容量最小的storage为准，所以建议group内的多个storage尽量配置相同，以免造成存储空间的浪费。 </p>
<p>​    以group为单位组织存储能方便的进行应用隔离、负载均衡、副本数定制（group内storage server数量即为该group的副本数），比如将不同应用数据存到不同的group就能隔离应用数据，同时还可根据应用的访问特性来将应用分配到不同的group来做负载均衡；缺点是group的容量受单机存储容量的限制，同时当group内有机器坏掉时，数据恢复只能依赖group内地其他机器，使得恢复时间会很长。 </p>
<p>​    group内每个storage的存储依赖于本地文件系统，storage可配置多个数据存储目录，比如有10块磁盘，分别挂载在/data/disk1-/data/disk10，则可将这10个目录都配置为storage的数据存储目录。 </p>
<p>​    storage接受到写文件请求时，会根据配置好的规则，选择其中一个存储目录来存储文件。为了避免单个目录下的文件数太多，在storage第一次启动时，会在每个数据存储目录里创建2级子目录，每级256个，总共65536个文件，新写的文件会以hash的方式被路由到其中某个子目录下，然后将文件数据直接作为一个本地文件存储到该目录中。</p>
<h3 id="Tracker-server"><a href="#Tracker-server" class="headerlink" title="Tracker server"></a><strong>Tracker server</strong></h3><p>​    Tracker是FastDFS的协调者，负责管理所有的storage server和group，每个storage在启动后会连接Tracker，告知自己所属的group等信息，并保持周期性的心跳，tracker根据storage的心跳信息，建立group==&gt;[storage server list]的映射表。 </p>
<p>​    Tracker需要管理的元信息很少，会全部存储在内存中；另外tracker上的元信息都是由storage汇报的信息生成的，本身不需要持久化任何数据，这样使得tracker非常容易扩展，直接增加tracker机器即可扩展为tracker cluster来服务，cluster里每个tracker之间是完全对等的，所有的tracker都接受stroage的心跳信息，生成元数据信息来提供读写服务。 </p>
<h3 id="Upload-file"><a href="#Upload-file" class="headerlink" title="Upload file"></a><strong>Upload file</strong></h3><p>​    FastDFS向使用者提供基本文件访问接口，比如upload、download、append、delete等，以客户端库的方式提供给用户使用。</p>
<p><img src="C:\Users\ADMINI~1\AppData\Local\Temp\1531230001197.png" alt="1531230001197"></p>
<p>1)选择tracker server </p>
<p>​    当集群中不止一个tracker server时，由于tracker之间是完全对等的关系，客户端在upload文件时可以任意选择一个trakcer。</p>
<p>2)选择存储的group </p>
<p>​    当tracker接收到upload file的请求时，会为该文件分配一个可以存储该文件的<strong>group</strong>，支持如下选择<strong>group</strong>的规则： </p>
<p>​    1. Round robin，所有的<strong>group</strong>间轮询 </p>
<p>​    2. Specified <strong>group</strong>，指定某一个确定的<strong>group</strong> </p>
<p>​    3. Load balance，剩余存储空间多多<strong>group</strong>优先</p>
<p>3)选择storage server </p>
<p>​    当选定<strong>group</strong>后，tracker会在<strong>group</strong>内选择一个storage server给客户端，支持如下选择storage的规则： </p>
<p>​    1. Round robin，在<strong>group</strong>内的所有storage间轮询 </p>
<p>​    2. First server ordered <strong>by</strong> ip，按ip排序 </p>
<p>​    3. First server ordered <strong>by</strong> priority，按优先级排序（优先级在storage上配置）</p>
<p>4)选择storage path </p>
<p>​    当分配好storage server后，客户端将向storage发送写文件请求，storage将会为文件分配一个数据存储目录，支持如下规则： </p>
<ol>
<li>Round robin，多个存储目录间轮询 </li>
<li>剩余存储空间最多的优先</li>
</ol>
<p>5)生成Fileid </p>
<p>​    选定存储目录之后，storage会为文件生一个Fileid，由storage server ip、文件创建时间、文件大小、文件crc32和一个随机数拼接而成，然后将这个二进制串进行base64编码，转换为可打印的字符串。</p>
<p>6)选择两级目录 </p>
<p>​    当选定存储目录之后，storage会为文件分配一个fileid，每个存储目录下有两级256*256的子目录，storage会按文件fileid进行两次hash（猜测），路由到其中一个子目录，然后将文件以fileid为文件名存储到该子目录下。</p>
<p>7)生成文件名 </p>
<p>​    当文件存储到某个子目录后，即认为该文件存储成功，接下来会为该文件生成一个文件名，文件名由<strong>group</strong>、存储目录、两级子目录、fileid、文件后缀名（由客户端指定，主要用于区分文件类型）拼接而成。</p>
<p><img src="C:\Users\ADMINI~1\AppData\Local\Temp\1531230108025.png" alt="1531230108025"></p>
<h4 id="文件同步"><a href="#文件同步" class="headerlink" title="文件同步"></a><strong>文件同步</strong></h4><p>​    写文件时，客户端将文件写至group内一个storage server即认为写文件成功，storage server写完文件后，会由后台线程将文件同步至同group内其他的storage server。 </p>
<p>​    每个storage写文件后，同时会写一份binlog，binlog里不包含文件数据，只包含文件名等元信息，这份binlog用于后台同步，storage会记录向group内其他storage同步的进度，以便重启后能接上次的进度继续同步；进度以时间戳的方式进行记录，所以最好能保证集群内所有server的时钟保持同步。 </p>
<p>​    storage的同步进度会作为元数据的一部分汇报到tracker上，tracke在选择读storage的时候会以同步进度作为参考。 </p>
<p>​    比如一个group内有A、B、C三个storage server，A向C同步到进度为T1 (T1以前写的文件都已经同步到B上了），B向C同步到时间戳为T2（T2 &gt; T1)，tracker接收到这些同步进度信息时，就会进行整理，将最小的那个做为C的同步时间戳，本例中T1即为C的同步时间戳为T1（即所有T1以前写的数据都已经同步到C上了）；同理，根据上述规则，tracker会为A、B生成一个同步时间戳。</p>
<h4 id="Download-file"><a href="#Download-file" class="headerlink" title="Download file"></a><strong>Download file</strong></h4><p>​    客户端upload file成功后，会拿到一个storage生成的文件名，接下来客户端根据这个文件名即可访问到该文件。</p>
<p><img src="C:\Users\ADMINI~1\AppData\Local\Temp\1531230217172.png" alt="1531230217172"></p>
<p>​    跟upload file一样，在download file时客户端可以选择任意tracker server。 </p>
<p>​    tracker发送download请求给某个tracker，必须带上文件名信息，tracke从文件名中解析出文件的group、大小、创建时间等信息，然后为该请求选择一个storage用来服务读请求。由于group内的文件同步时在后台异步进行的，所以有可能出现在读到时候，文件还没有同步到某些storage server上，为了尽量避免访问到这样的storage，tracker按照如下规则选择group内可读的storage。 </p>
<p>​    1. 该文件上传到的源头storage - 源头storage只要存活着，肯定包含这个文件，源头的地址被编码在文件名中。 </p>
<p>​    2. 文件创建时间戳==storage被同步到的时间戳且(当前时间-文件创建时间戳) &gt; 文件同步最大时间（如5分钟) - 文件创建后，认为经过最大同步时间后，肯定已经同步到其他storage了。 </p>
<p>​    3. 文件创建时间戳 &lt; storage被同步到的时间戳。 - 同步时间戳之前的文件确定已经同步了 。</p>
<pre><code>4. (当前时间-文件创建时间戳) &gt; 同步延迟阀值（如一天）。 - 经过同步延迟阈值时间，认为文件肯定已经同步了。
</code></pre><h4 id="小文件合并存储"><a href="#小文件合并存储" class="headerlink" title="小文件合并存储"></a><strong>小文件合并存储</strong></h4><p>​    将小文件合并存储主要解决如下几个问题： </p>
<p>​    1. 本地文件系统inode数量有限，从而存储的小文件数量也就受到限制。 </p>
<p>​    2. 多级目录+目录里很多文件，导致访问文件的开销很大（可能导致很多次IO） </p>
<p>​    3. 按小文件存储，备份与恢复的效率低</p>
<p>​    FastDFS在V3.0版本里引入小文件合并存储的机制，可将多个小文件存储到一个大的文件（trunk file），为了支持这个机制，FastDFS生成的文件fileid需要额外增加16个字节 </p>
<p>​    1. trunk file id </p>
<p>​    2. 文件在trunk file内部的offset </p>
<p>​    3. 文件占用的存储空间大小,字节对齐及删除空间复用，文件占用存储空间&gt;=文件大小</p>
<p>​    每个trunk file由一个id唯一标识，trunk file由group内的trunk server负责创建（trunk server是tracker选出来的），并同步到group内其他的storage，文件存储合并存储到trunk file后，根据其offset就能从trunk file读取到文件。 </p>
<p>​    文件在trunk file内的offset编码到文件名，决定了其在trunk file内的位置是不能更改的，也就不能通过compact的方式回收trunk file内删除文件的空间。但当trunk file内有文件删除时，其删除的空间是可以被复用的，比如一个100KB的文件被删除，接下来存储一个99KB的文件就可以直接复用这片删除的存储空间。 </p>
<h4 id="HTTP访问支持"><a href="#HTTP访问支持" class="headerlink" title="HTTP访问支持"></a><strong>HTTP访问支持</strong></h4><p>​    FastDFS的tracker和storage都内置了http协议的支持，客户端可以通过http协议来下载文件，tracker在接收到请求时，通过http的redirect机制将请求重定向至文件所在的storage上；除了内置的http协议外，FastDFS还提供了通过apache或nginx扩展模块下载文件的支持。</p>
<p><img src="C:\Users\ADMINI~1\AppData\Local\Temp\1531230310182.png" alt="1531230310182"></p>
<h4 id="其他特性"><a href="#其他特性" class="headerlink" title="其他特性"></a>其他特性</h4><p>​    FastDFS提供了设置/获取文件扩展属性的接口（setmeta/getmeta)，扩展属性以key-value对的方式存储在storage上的同名文件（拥有特殊的前缀或后缀），比如/group/M00/00/01/some_file为原始文件，则该文件的扩展属性存储在/group/M00/00/01/.some_file.meta文件（真实情况不一定是这样，但机制类似），这样根据文件名就能定位到存储扩展属性的文件。 </p>
<p>​    以上两个接口作者不建议使用，额外的meta文件会进一步“放大”海量小文件存储问题，同时由于meta非常小，其存储空间利用率也不高，比如100bytes的meta文件也需要占用4K（block_size）的存储空间。 </p>
<p>​    FastDFS还提供appender file的支持，通过upload_appender_file接口存储，appender file允许在创建后，对该文件进行append操作。实际上，appender file与普通文件的存储方式是相同的，不同的是，appender file不能被合并存储到trunk file。</p>

        </section>
    </article>
    
        <!-- disqus 评论框 start -->
        <div class="comment">
            <div id="disqus_thread" class="disqus-thread">
              <i>加载评论框需要翻墙</i>
            </div>
        </div>
        <!-- disqus 评论框 end -->
    
    
        <!-- livere 评论框 start -->
        <div class="comment">
            <div id="lv-container" data-id="city" data-uid="your_livere_uid"></div>
        </div>
        <!-- livere 评论框 end -->
        
  </div>
  <aside>
    
    <div class="toc-container">
        <h1>目录</h1>
        <div class="content">
            <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#FastDFS介绍"><span class="toc-number">1.</span> <span class="toc-text">FastDFS介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Tracker-server"><span class="toc-number">2.</span> <span class="toc-text">Tracker server</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Upload-file"><span class="toc-number">3.</span> <span class="toc-text">Upload file</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#文件同步"><span class="toc-number">3.1.</span> <span class="toc-text">文件同步</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Download-file"><span class="toc-number">3.2.</span> <span class="toc-text">Download file</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#小文件合并存储"><span class="toc-number">3.3.</span> <span class="toc-text">小文件合并存储</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP访问支持"><span class="toc-number">3.4.</span> <span class="toc-text">HTTP访问支持</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#其他特性"><span class="toc-number">3.5.</span> <span class="toc-text">其他特性</span></a></li></ol></li></ol>
        </div>
    </div>
    
  </aside>
</main>

<!-- disqus 公共JS代码 -->
<script type="text/javascript">
  /* * * CONFIGURATION VARIABLES * * */
  var disqus_shortname = "your_disqus_shortname";
  var disqus_identifier = "http://yoursite.com/2018/07/10/FastDFS分布式文件系统/";
  var disqus_url = "http://yoursite.com/2018/07/10/FastDFS分布式文件系统/";

  isAgent(getDisqus)

  // determine user agent in China
  function isAgent(cb) {
    var url = '//graph.facebook.com/feed?callback=h';
    var xhr = new XMLHttpRequest();
    var called = false;
    xhr.open('GET', url);
    xhr.onreadystatechange = function() {
      if (xhr.readyState === 4 && xhr.status === 200) {
      called = true;
      cb(true);
      }
    };
    xhr.send();
    // timeout 1s, this facebook API is very fast.
    setTimeout(function() {
      if (!called) {
      xhr.abort();
      cb(false)
      }
    }, 1000);
  }

  function getDisqus(isAgent) {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; 
    dsq.async = true
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq)
  }
</script>
<!-- disqus 公共JS代码 end -->


<script type="text/javascript">
  (function(d, s) {
      var j, e = d.getElementsByTagName(s)[0];

      if (typeof LivereTower === 'function') { return; }

      j = d.createElement(s);
      j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
      j.async = true;

      e.parentNode.insertBefore(j, e);
  })(document, 'script');
</script>


  <footer>
  <div class="copyright">
    <div>
      &copy; 2018 | Powered by <a href="https://hexo.io" target="_blank">Hexo</a>&nbsp
    </div>
    <div>
      Theme by <a href="https://github.com/lewis-geek/hexo-theme-Aath" target="_blank">Aath</a>
    </div>
  </div>
</footer>


<script src="https://cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>
<script src="/lib/in-view.min.js"></script>
<script src="/lib/lodash.min.js"></script>
<script>
  var isDown = true
  var oldY = 0
  inView.offset(50)

  document.body.addEventListener('touchstart', function(){});
  
  window.addEventListener('scroll', _.throttle(e => {
    var currentY = window.scrollY
    if((oldY - currentY) < 0) {
      isDown = true
    } else {
      isDown = false
    }
    oldY = currentY
  }, 250))

  $("article img").each(function() {
      var strA = "<a data-fancybox='gallery' href='" + this.src + "'></a>";
      $(this).wrapAll(strA);
  });

  $('.toc-link').each(function() {
      var href = $(this).attr("href");
      
      inView(href).on('exit', () => {
        if (isDown) {
          handleActive(href)
        }
      })

      inView(href).on('enter', () => {
        if (!isDown) {
          handleActive(href)
        }
      })

      this.onclick = function(e) {
        var pos = $(href).offset().top - 10;
        $("html,body").animate({scrollTop: pos}, 300);
        setTimeout(() => {
          handleActive(href)
        }, 350)
        return false
      }
  })

  function handleActive(href) {
    document.querySelectorAll('.toc-link').forEach(elm => {
      elm.classList.remove('active')
    })
    document.querySelector(".toc [href='"+ href +"']").classList.add('active')
  }
</script>
<script src="/lib/jquery.fancybox.min.js"></script>


</body>
</html>
